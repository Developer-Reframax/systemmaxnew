[{"filePath":"C:\\Users\\garibaldi.neto\\systemmaxnew\\api\\app.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_next' is defined but never used.","line":43,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":58}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * This is a API server\r\n */\r\n\r\n// load env first\r\nimport dotenv from 'dotenv'\r\ndotenv.config()\r\n\r\nimport express, {\r\n  type Request,\r\n  type Response,\r\n  type NextFunction,\r\n} from 'express'\r\nimport cors from 'cors'\r\nimport authRoutes from './routes/auth.js'\r\n\r\n// ESM mode helpers were unused; removed to satisfy lint\r\n\r\nconst app: express.Application = express()\r\n\r\napp.use(cors())\r\napp.use(express.json({ limit: '10mb' }))\r\napp.use(express.urlencoded({ extended: true, limit: '10mb' }))\r\n\r\n/**\r\n * API Routes\r\n */\r\napp.use('/api/auth', authRoutes)\r\n\r\n/**\r\n * health\r\n */\r\napp.use('/api/health', (req: Request, res: Response): void => {\r\n  res.status(200).json({\r\n    success: true,\r\n    message: 'ok',\r\n  })\r\n})\r\n\r\n/**\r\n * error handler middleware\r\n */\r\napp.use((error: Error, req: Request, res: Response, _next: NextFunction): void => {\r\n  res.status(500).json({\r\n    success: false,\r\n    error: 'Server internal error',\r\n  })\r\n})\r\n\r\n/**\r\n * 404 handler\r\n */\r\napp.use((req: Request, res: Response): void => {\r\n  res.status(404).json({\r\n    success: false,\r\n    error: 'API not found',\r\n  })\r\n})\r\n\r\nexport default app\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\garibaldi.neto\\systemmaxnew\\api\\routes\\auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'password_hash' is assigned a value but never used.","line":72,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * User authentication API routes\r\n * Handle user registration, login, token management, etc.\r\n */\r\nimport { Router, Request, Response } from 'express'\r\nimport bcrypt from 'bcrypt'\r\nimport jwt from 'jsonwebtoken'\r\nimport { supabase } from '../config/supabase.js'\r\n\r\nconst router = Router()\r\n\r\n// JWT secret key\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production'\r\n\r\n/**\r\n * User Login\r\n * POST /api/auth/login\r\n */\r\nrouter.post('/login', async (req: Request, res: Response): Promise<void> => {\r\n  try {\r\n    const { email, password } = req.body\r\n\r\n    // Validação dos campos obrigatórios\r\n    if (!email || !password) {\r\n      res.status(400).json({ \r\n        success: false, \r\n        message: 'Email e senha são obrigatórios' \r\n      })\r\n      return\r\n    }\r\n\r\n    // Buscar usuário no banco usando service_role_key\r\n    const { data: user, error } = await supabase\r\n      .from('usuarios')\r\n      .select('*')\r\n      .eq('email', email)\r\n      .eq('status', 'ativo')\r\n      .single()\r\n\r\n    if (error || !user) {\r\n      res.status(401).json({ \r\n        success: false, \r\n        message: 'Credenciais inválidas' \r\n      })\r\n      return\r\n    }\r\n\r\n    // Verificar senha com bcrypt\r\n    const isPasswordValid = await bcrypt.compare(password, user.password_hash)\r\n\r\n    if (!isPasswordValid) {\r\n      res.status(401).json({ \r\n        success: false, \r\n        message: 'Credenciais inválidas' \r\n      })\r\n      return\r\n    }\r\n\r\n    // Gerar JWT token\r\n    const token = jwt.sign(\r\n      { \r\n        matricula: user.matricula,\r\n        email: user.email,\r\n        role: user.role,\r\n        nome: user.nome\r\n      },\r\n      JWT_SECRET,\r\n      { expiresIn: '24h' }\r\n    )\r\n\r\n    // Retornar dados do usuário (sem senha) e token\r\n    const { password_hash, ...userWithoutPassword } = user\r\n    \r\n    res.status(200).json({\r\n      success: true,\r\n      message: 'Login realizado com sucesso',\r\n      data: {\r\n        user: userWithoutPassword,\r\n        token\r\n      }\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Erro no login:', error)\r\n    res.status(500).json({ \r\n      success: false, \r\n      message: 'Erro interno do servidor' \r\n    })\r\n  }\r\n})\r\n\r\n/**\r\n * User Registration\r\n * POST /api/auth/register\r\n */\r\nrouter.post('/register', async (req: Request, res: Response): Promise<void> => {\r\n  // TODO: Implement register logic\r\n  res.status(501).json({ success: false, message: 'Not implemented' })\r\n})\r\n\r\n\r\n\r\n/**\r\n * User Verification\r\n * POST /api/auth/verify\r\n */\r\ninterface TokenPayload extends jwt.JwtPayload {\r\n  matricula: string\r\n  email?: string\r\n  role?: string\r\n  nome?: string\r\n}\r\n\r\nrouter.post('/verify', async (req: Request, res: Response) => {\r\n  try {\r\n    const authHeader = req.headers.authorization\r\n    const token = authHeader && authHeader.split(' ')[1]\r\n\r\n    if (!token) {\r\n      return res.status(401).json({ success: false, message: 'Token de acesso requerido' })\r\n    }\r\n\r\n    // Verify JWT token\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload\r\n    const { matricula } = req.body\r\n\r\n    if (decoded.matricula !== matricula) {\r\n      return res.status(403).json({ success: false, message: 'Token inválido para este usuário' })\r\n    }\r\n\r\n    // Check if user still exists and is active\r\n    const { data: user, error } = await supabase\r\n      .from('usuarios')\r\n      .select('matricula, nome, email, role, funcao, contrato_raiz, status')\r\n      .eq('matricula', matricula)\r\n      .eq('status', 'ativo')\r\n      .single()\r\n\r\n    if (error || !user) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Usuário não encontrado ou inativo'\r\n      })\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      user: {\r\n        matricula: user.matricula,\r\n        nome: user.nome,\r\n        email: user.email,\r\n        role: user.role,\r\n        funcao: user.funcao,\r\n        contrato_raiz: user.contrato_raiz\r\n      }\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Verify user error:', error)\r\n    res.status(403).json({\r\n      success: false,\r\n      message: 'Token inválido'\r\n    })\r\n  }\r\n})\r\n\r\n/**\r\n * Create Session\r\n * POST /api/auth/session\r\n */\r\nrouter.post('/session', async (req: Request, res: Response) => {\r\n  try {\r\n    const authHeader = req.headers.authorization\r\n    const token = authHeader && authHeader.split(' ')[1]\r\n\r\n    if (!token) {\r\n      return res.status(401).json({ success: false, message: 'Token de acesso requerido' })\r\n    }\r\n\r\n    // Verify JWT token\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload\r\n    const { matricula_usuario, inicio_sessao, paginas_acessadas, modulos_acessados } = req.body\r\n\r\n    if (decoded.matricula !== matricula_usuario) {\r\n      return res.status(403).json({ success: false, message: 'Token inválido para este usuário' })\r\n    }\r\n\r\n    // Create session record\r\n    const { data: session, error } = await supabase\r\n      .from('sessoes')\r\n      .insert({\r\n        matricula_usuario,\r\n        inicio_sessao,\r\n        paginas_acessadas: paginas_acessadas || 1,\r\n        modulos_acessados: modulos_acessados || ['Login']\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (error) {\r\n      console.error('Session creation error:', error)\r\n      return res.status(500).json({\r\n        success: false,\r\n        message: 'Erro ao criar sessão'\r\n      })\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Sessão criada com sucesso',\r\n      session\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Session creation error:', error)\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    })\r\n  }\r\n})\r\n\r\n/**\r\n * User Logout\r\n * POST /api/auth/logout\r\n */\r\n// Logout route\r\nrouter.post('/logout', async (req: Request, res: Response) => {\r\n  try {\r\n    const authHeader = req.headers.authorization\r\n    const token = authHeader && authHeader.split(' ')[1]\r\n\r\n    if (!token) {\r\n      return res.status(401).json({ success: false, message: 'Token de acesso requerido' })\r\n    }\r\n\r\n    // Verify JWT token\r\n    const decoded = jwt.verify(token, JWT_SECRET) as TokenPayload\r\n    const { matricula_usuario, fim_sessao } = req.body\r\n\r\n    if (decoded.matricula !== matricula_usuario) {\r\n      return res.status(403).json({ success: false, message: 'Token inválido para este usuário' })\r\n    }\r\n\r\n    // Find and update the active session\r\n    const { data: sessions, error: selectError } = await supabase\r\n      .from('sessoes')\r\n      .select('id, inicio_sessao')\r\n      .eq('matricula_usuario', matricula_usuario)\r\n      .is('fim_sessao', null)\r\n      .order('inicio_sessao', { ascending: false })\r\n      .limit(1)\r\n\r\n    if (selectError) {\r\n      console.error('Session select error:', selectError)\r\n      return res.status(500).json({\r\n        success: false,\r\n        message: 'Erro ao buscar sessão'\r\n      })\r\n    }\r\n\r\n    if (sessions && sessions.length > 0) {\r\n      const session = sessions[0]\r\n      const startTime = new Date(session.inicio_sessao).getTime()\r\n      const endTime = new Date(fim_sessao).getTime()\r\n      const tempo_total_segundos = Math.floor((endTime - startTime) / 1000)\r\n\r\n      const { error: updateError } = await supabase\r\n        .from('sessoes')\r\n        .update({\r\n          fim_sessao,\r\n          tempo_total_segundos\r\n        })\r\n        .eq('id', session.id)\r\n\r\n      if (updateError) {\r\n        console.error('Session update error:', updateError)\r\n        return res.status(500).json({\r\n          success: false,\r\n          message: 'Erro ao finalizar sessão'\r\n        })\r\n      }\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Logout realizado com sucesso'\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Logout error:', error)\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    })\r\n  }\r\n})\r\n\r\nexport default router\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\garibaldi.neto\\systemmaxnew\\api\\routes\\session.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":28,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Router, Request, Response, NextFunction } from 'express'\r\nimport jwt from 'jsonwebtoken'\r\nimport { supabase } from '../config/supabase.js'\r\n\r\nconst router = Router()\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET!\r\n\r\ninterface TokenPayload extends jwt.JwtPayload {\r\n  matricula: string\r\n  email?: string\r\n  role?: string\r\n  nome?: string\r\n}\r\n\r\n// Middleware to verify JWT token\r\nconst verifyToken = (req: Request, res: Response, next: NextFunction) => {\r\n  const authHeader = req.headers.authorization\r\n  const token = authHeader && authHeader.split(' ')[1]\r\n\r\n  if (!token) {\r\n    return res.status(401).json({ success: false, message: 'Token de acesso requerido' })\r\n  }\r\n\r\n  try {\r\n    jwt.verify(token, JWT_SECRET) as TokenPayload\r\n    next()\r\n  } catch (error) {\r\n    return res.status(403).json({ success: false, message: 'Token inválido' })\r\n  }\r\n}\r\n\r\n// Create session\r\nrouter.post('/', verifyToken, async (req: Request, res: Response) => {\r\n  try {\r\n    const { matricula_usuario, inicio_sessao, paginas_acessadas, modulos_acessados } = req.body\r\n\r\n    if (!matricula_usuario || !inicio_sessao) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Dados obrigatórios não fornecidos'\r\n      })\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('sessoes')\r\n      .insert({\r\n        matricula_usuario,\r\n        inicio_sessao,\r\n        paginas_acessadas: paginas_acessadas || 1,\r\n        modulos_acessados: modulos_acessados || ['Login']\r\n      })\r\n      .select()\r\n      .single()\r\n\r\n    if (error) {\r\n      console.error('Session creation error:', error)\r\n      return res.status(500).json({\r\n        success: false,\r\n        message: 'Erro ao criar sessão'\r\n      })\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      session: data,\r\n      message: 'Sessão criada com sucesso'\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Session creation error:', error)\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    })\r\n  }\r\n})\r\n\r\n// Update session (for logout)\r\nrouter.put('/:sessionId', verifyToken, async (req: Request, res: Response) => {\r\n  try {\r\n    const { sessionId } = req.params\r\n    const { fim_sessao, tempo_total_segundos, paginas_acessadas, modulos_acessados } = req.body\r\n\r\n    const updateData: Partial<{\r\n      fim_sessao: string\r\n      tempo_total_segundos: number\r\n      paginas_acessadas: number\r\n      modulos_acessados: string[]\r\n    }> = {}\r\n    if (fim_sessao) updateData.fim_sessao = fim_sessao\r\n    if (tempo_total_segundos) updateData.tempo_total_segundos = tempo_total_segundos\r\n    if (paginas_acessadas) updateData.paginas_acessadas = paginas_acessadas\r\n    if (modulos_acessados) updateData.modulos_acessados = modulos_acessados\r\n\r\n    const { data, error } = await supabase\r\n      .from('sessoes')\r\n      .update(updateData)\r\n      .eq('id', sessionId)\r\n      .select()\r\n      .single()\r\n\r\n    if (error) {\r\n      console.error('Session update error:', error)\r\n      return res.status(500).json({\r\n        success: false,\r\n        message: 'Erro ao atualizar sessão'\r\n      })\r\n    }\r\n\r\n    res.json({\r\n      success: true,\r\n      session: data,\r\n      message: 'Sessão atualizada com sucesso'\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Session update error:', error)\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    })\r\n  }\r\n})\r\n\r\nexport default router","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]